#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
rush_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush - Personal package manager\n"
    echo 
  else
    printf "rush - Personal package manager\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush [command] [options]\n"
  printf "  rush [command] --help | -h\n"
  printf "  rush --version\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  add       Register a local repository"
  echo "  clone     Clone a GitHub package repository"
  echo "  remove    Unregister a local repository"
  echo "  config    Show the configuration file"
  echo "  get       Install a package (default)"
  echo "  undo      Uninstall a package"
  echo "  info      Show information about a package"
  echo "  list      Show packages in one or all repositories"
  echo "  pull      Git pull one or all repositories"
  echo "  push      Git push one or all repositories"
  echo "  default   Set a default repository"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"
    
    # :environment_variable.usage
    echo "  RUSH_CONFIG"
    printf "    Location of the rush config file\n    Default: ~/rush.ini\n"
    echo

  fi
}

# :command.usage
rush_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush add\n"
    echo 
    printf "  Register a local repository\n  This command adds the specified path to the configuration file.\n"
    echo 
  else
    printf "rush add - Register a local repository\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush add REPO PATH [options]\n"
  printf "  rush add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name\n"
    echo
    
    # :argument.usage
    echo "  PATH"
    printf "    Path to the repository\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush add default ~/rush-repos/default\n"
    echo

  fi
}

# :command.usage
rush_clone_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush clone\n"
    echo 
    printf "  Clone a GitHub package repository\n  This command clones the repository and registers it in the\n  configuration file.\n"
    echo 
  else
    printf "rush clone - Clone a GitHub package repository\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush clone GITHUB_USER [PATH] [options]\n"
  printf "  rush clone --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --ssh, -s"
    printf "    Clone using SSH instead of HTTPS\n"
    echo
    
    # :flag.usage
    echo "  --name, -n NAME"
    printf "    Name to use in the config file\n    Default: GitHub user\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  GITHUB_USER"
    printf "    Github user\n    This user is expected to have a repository named 'rush-repo'.\n    If you need to use a different name, use the 'user/repo' syntax.\n"
    echo
    
    # :argument.usage
    echo "  PATH"
    printf "    Local path to clone the repository to\n    Default: ~/rush-repos/<github_user>/<github_repo>\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush clone bobby\n"
    printf "  rush clone bobby/bobs-repo ./repos/bobby --ssh\n"
    printf "  rush clone bobby --name sample\n"
    echo

  fi
}

# :command.usage
rush_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush remove\n"
    echo 
    printf "  Unregister a local repository\n  This command removes the specified path to the configuration file.\n"
    echo 
  else
    printf "rush remove - Unregister a local repository\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush remove REPO [options]\n"
  printf "  rush remove --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name\n"
    echo

  fi
}

# :command.usage
rush_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush config - Show the configuration file\n"
    echo 
  else
    printf "rush config - Show the configuration file\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush config [options]\n"
  printf "  rush config --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --edit, -e"
    printf "    Open the configuration file for editing\n"
    echo

  fi
}

# :command.usage
rush_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush get\n"
    echo 
    printf "  Install a package\n  This command runs the main script in the package directory.\n"
    echo 
  else
    printf "rush get - Install a package\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush get PACKAGE [options]\n"
  printf "  rush get --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush get ruby\n"
    printf "  rush get centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_undo_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush undo\n"
    echo 
    printf "  Uninstall a package\n  This command runs the undo script in the package directory.\n"
    echo 
  else
    printf "rush undo - Uninstall a package\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush undo PACKAGE [options]\n"
  printf "  rush undo --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush undo ruby\n"
    printf "  rush undo centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_info_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush info\n"
    echo 
    printf "  Show information about a package\n  This command shows the info file from the package directory.\n"
    echo 
  else
    printf "rush info - Show information about a package\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush info PACKAGE [options]\n"
  printf "  rush info --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush info ruby\n"
    printf "  rush info centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush list - Show packages in one or all repositories\n"
    echo 
  else
    printf "rush list - Show packages in one or all repositories\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush list [REPO_OR_PACKAGE] [options]\n"
  printf "  rush list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --search, -s TEXT"
    printf "    Show only packages that have TEXT in their name\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO_OR_PACKAGE"
    printf "    Repository name or package name\n    - Leave blank to show all packages in all repositories.\n    - Provide a repository name to show only packages in this repository.\n    - Provide a package name (may be in the form of 'repo:package') to\n      show nested packages.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush list\n"
    printf "  rush list personal:apps\n"
    printf "  rush list personal\n"
    printf "  rush list apps\n"
    printf "  rush list apps --search graphviz\n"
    echo

  fi
}

# :command.usage
rush_pull_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush pull - Git pull one or all repositories\n"
    echo 
  else
    printf "rush pull - Git pull one or all repositories\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush pull [REPO] [options]\n"
  printf "  rush pull --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name\n"
    echo

  fi
}

# :command.usage
rush_push_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush push - Git push one or all repositories\n"
    echo 
  else
    printf "rush push - Git push one or all repositories\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush push [REPO] [options]\n"
  printf "  rush push --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --message, -m TEXT"
    printf "    Commit message\n    Default: automatic commit\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name\n"
    echo

  fi
}

# :command.usage
rush_default_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush default\n"
    echo 
    printf "  Set a default repository\n  This command adds (or updates) a repository named 'default' to the\n  configuration file, and copies the path from the provided repo.\n"
    echo 
  else
    printf "rush default - Set a default repository\n"
    echo 
  fi
  printf "Usage:\n"
  printf "  rush default REPO [options]\n"
  printf "  rush default --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush default sample\n"
    echo

  fi
}

# :command.inspect_args
inspect_args() {
  echo args:
  for k in "${!args[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
}

# :command.user_lib
# :src/lib/abort.sh
abort() {
  red "$1"
  exit 1
}

# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
# 
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/config.sh
# ---
# Config functions
# This file is a part of Bashly standard library
#
# Usage:
# - In your script, set the CONFIG_FILE variable. For rxample:
#   CONFIG_FILE=settings.ini.
#   If it is unset, it will default to 'config.ini'.
# - Use any of the functions below to access the config file.
# ---

# Create a new config file.
# There is normally no need to use this fucntion, it is used by other
# functions as needed.
config_init() {
  CONFIG_FILE=${CONFIG_FILE:=config.ini}
  [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
}

# Get a value from the config
# Usage: result=$(config_get hello)
config_get() {
  key=$1
  regex="^$key\s*=\s*(.+)$"

  config_init
  
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[1]}"
      break
    fi
  done < "$CONFIG_FILE"

  echo "$value"
}

# Add or update a key=value pair in the config.
# Usage: config_set key value
config_set() {
  key=$1
  shift
  value="$*"

  config_init

  regex="^($key)\s*=\s*.+$"
  output=""
  found_key=""
  
  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[1]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Delete a key from teh config.
# Usage: config_del key
config_del() {
  key=$1

  regex="^($key)\s*="
  output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Show the config file
config_show() {
  config_init
  cat "$CONFIG_FILE"
}

# Return an array of the keys in the config file
# Usage:
#
#   for k in $(config_keys); do
#     echo "- $k = $(config_get "$k")";
#   done
#
config_keys() {
  regex="^(.*)\s*="

  config_init

  keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      keys+=("$key")
    fi
  done < "$CONFIG_FILE"
  echo "${keys[@]}"
}

# :command.command_functions
# :command.function
rush_add_command() {
  # :src/add_command.sh
  repo=${args[repo]}
  path=${args[path]}
  
  config_set "$repo" "$path"
  echo "add $(green "$repo:$path")"
}

# :command.function
rush_clone_command() {
  # :src/clone_command.sh
  # Collect variables
  path=${args[path]}
  repo_id=${args[github_user]}
  use_ssh=${args[--ssh]}
  default_repo_name=${repo_id%%/*}
  repo_name=${args[--name]:-$default_repo_name}
  
  # Adjust repo_id - defaults to $user/rush-repo
  [[ $repo_id = */* ]] || repo_id="$repo_id/rush-repo"
  
  # Set clone URL - ssh or https?
  if [[ $use_ssh ]]; then
    repo_url=git@github.com:$repo_id.git
  else
    repo_url=https://github.com/$repo_id.git
  fi
  
  # Set default path if not provided
  [[ $path ]] || path="$HOME/rush-repos/$repo_id"
  
  # Abort if target directory exists
  [[ -d $path ]] && abort "Directory $path already exists."
  
  set -e
  
  # Clone
  git clone "$repo_url" "$path"
  
  # Save config
  config_set "$repo_name" "$path"
}

# :command.function
rush_remove_command() {
  # :src/remove_command.sh
  repo=${args[repo]}
  config_del "$repo"
  echo "remove $(green "$repo")"
}

# :command.function
rush_config_command() {
  # :src/config_command.sh
  if [[ "${args[--edit]}" ]]; then
    editor="${EDITOR:-vi}"
    "$editor" "$CONFIG_FILE"
  else
    cyan "# $CONFIG_FILE"
    config_show
  fi
}

# :command.function
rush_get_command() {
  # :src/get_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  repo_path=$(config_get "$repo")
  package_path=$repo_path/$package
  script=$package_path/main
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $script ]] || abort "script not found: $script"
  
  # Run the script (make it executable if it isnt first)
  export REPO="$repo"
  echo "run $(green "$repo:$package")"
  [[ -x "$script" ]] || chmod u+x "$script"
  cd "$package_path"
  ./main
}

# :command.function
rush_undo_command() {
  # :src/undo_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  repo_path=$(config_get "$repo")
  package_path=$repo_path/$package
  script=$package_path/undo
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $script ]] || abort "script not found: $script"
  
  # Run the script (make it executable if it isnt first)
  export REPO="$repo"
  echo "run $(green "$repo:$package")"
  [[ -x "$script" ]] || chmod u+x "$script"
  cd "$package_path"
  ./undo
}

# :command.function
rush_info_command() {
  # :src/info_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  repo_path=$(config_get "$repo")
  package_path=$repo_path/$package
  infofile=$package_path/info
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo/$package"
  [[ -f $infofile ]] || abort "infofile not found: $infofile"
  
  # Show the info file
  cat "$infofile"
}

# :command.function
rush_list_command() {
  # :src/list_command.sh
  show_repo_list() {
    repo_or_package="$1"
    search="${args[--search]}"
    repo="$1"
  
    if [[ $repo_or_package =~ (.*):(.*) ]]; then
      repo=${BASH_REMATCH[1]}
      package=${BASH_REMATCH[2]}
    fi
  
    repo_path=$(config_get "$repo")
  
    if [[ ! $repo_path ]]; then
      package="$repo"
      repo="default"
      repo_path=$(config_get "$repo")
    fi
  
    green "$repo:"
  
    if [[ $package ]]; then
      glob=( "$repo_path"/"$package"/*/info )
    else
      glob=( "$repo_path"/*/info )
    fi
  
    if [[ ${glob[0]} =~ \* ]]; then
      infofile="$repo_path/$package/info"
      if [[ -f "$infofile" ]]; then
        info=$(head -1 "$infofile" 2> /dev/null)
        printf "  %-26s $info\n" "$(blue "$package")"
      else
        red "  no matches"
      fi
    
    else
      for infofile in "${glob[@]}"; do
        if [[ $search ]]; then
          regex="$repo_path/(.*${search}.*)/info"
        else
          regex="$repo_path/(.*)/info"
        fi
  
        if [[ $infofile =~ $regex ]]; then
          package_name="${BASH_REMATCH[1]}"
          info=$(head -1 "$infofile" 2> /dev/null)
          printf "  %-26s $info\n" "$(blue "$package_name")"
        fi
      done
    fi
  
    echo
  }
  
  repo_or_package=${args[repo_or_package]}
  
  if [[ $repo_or_package ]]; then
    show_repo_list "$repo_or_package"
  else
    for k in $(config_keys); do
      show_repo_list "$k"
    done
  fi
}

# :command.function
rush_pull_command() {
  # :src/pull_command.sh
  repo=${args[repo]}
  
  pull_repo() {
    local repo_path="$1"
    local repo="$2"
  
    if [[ -d "$repo_path/.git" ]]; then
      echo "pull $(green "$repo")"
      git -C "$repo_path" pull
    else
      echo "skip $(blue "$repo") (not a git repo)"
    fi
  }
  
  if [[ $repo ]]; then
    repo_path=$(config_get "$repo")
    [[ $repo_path ]] || abort "no such repo: $repo"
    pull_repo "$repo_path" "$repo"
  else
    for k in $(config_keys); do
      pull_repo "$(config_get "$k")" "$k"
    done
  fi
}

# :command.function
rush_push_command() {
  # :src/push_command.sh
  set +e
  repo=${args[repo]}
  message=${args[--message]:-"automatic commit"}
  
  push_repo() {
    local repo_path="$1"
    local repo="$2"
  
    if [[ -d "$repo_path/.git" ]]; then
      echo "push $(green "$repo")"
      git -C "$repo_path" add . --all && git -C "$repo_path" commit -am "$message" && git -C "$repo_path" push
    else
      echo "skip $(blue "$repo") (not a git repo)"
    fi
  }
  
  if [[ $repo ]]; then
    repo_path=$(config_get "$repo")
    [[ $repo_path ]] || abort "no such repo: $repo"
    push_repo "$repo_path" "$repo"
  else
    for k in $(config_keys); do
      push_repo "$(config_get "$k")" "$k"
    done
  fi
}

# :command.function
rush_default_command() {
  # :src/default_command.sh
  # Collect variables
  repo=${args[repo]}
  repo_path=$(config_get "$repo")
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  
  config_set "default" "$repo_path"
  config_del "$repo"
  echo "default $(green "$repo")"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  add | a )
    action="add"
    shift
    rush_add_parse_requirements "$@"
    shift $#
    ;;    
  
  clone )
    action="clone"
    shift
    rush_clone_parse_requirements "$@"
    shift $#
    ;;    
  
  remove | r )
    action="remove"
    shift
    rush_remove_parse_requirements "$@"
    shift $#
    ;;    
  
  config | c )
    action="config"
    shift
    rush_config_parse_requirements "$@"
    shift $#
    ;;    
  
  get | g )
    action="get"
    shift
    rush_get_parse_requirements "$@"
    shift $#
    ;;    
  
  undo | u )
    action="undo"
    shift
    rush_undo_parse_requirements "$@"
    shift $#
    ;;    
  
  info | i )
    action="info"
    shift
    rush_info_parse_requirements "$@"
    shift $#
    ;;    
  
  list | l )
    action="list"
    shift
    rush_list_parse_requirements "$@"
    shift $#
    ;;    
  
  pull | p )
    action="pull"
    shift
    rush_pull_parse_requirements "$@"
    shift $#
    ;;    
  
  push )
    action="push"
    shift
    rush_push_parse_requirements "$@"
    shift $#
    ;;    
  
  default )
    action="default"
    shift
    rush_default_parse_requirements "$@"
    shift $#
    ;;    
  
  "" )
    rush_usage
    exit 1
    ;;
  
  * )
    action="get"
    rush_get_parse_requirements "$@"
    shift $#
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_add_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_add_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="add"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[repo]=$1
    shift
  else
    printf "missing required argument: REPO\nusage: rush add REPO PATH [options]\n"
    exit 1
  fi
  
  if [[ $1 && $1 != -* ]]; then
    args[path]=$1
    shift
  else
    printf "missing required argument: PATH\nusage: rush add REPO PATH [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      elif [[ ! ${args[path]} ]]; then
        args[path]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_clone_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_clone_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="clone"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[github_user]=$1
    shift
  else
    printf "missing required argument: GITHUB_USER\nusage: rush clone GITHUB_USER [PATH] [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --ssh | -s )
      args[--ssh]=1
      shift
      ;;
  
    # :flag.case
    --name | -n )
      if [[ $2 && $2 != -* ]]; then
        args[--name]="$2"
        shift
        shift
      else
        printf "--name requires an argument: --name, -n NAME\n"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[github_user]} ]]; then
        args[github_user]=$1
        shift
      elif [[ ! ${args[path]} ]]; then
        args[path]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_remove_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_remove_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="remove"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[repo]=$1
    shift
  else
    printf "missing required argument: REPO\nusage: rush remove REPO [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_config_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_config_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="config"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --edit | -e )
      args[--edit]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_get_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_get_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="get"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush get PACKAGE [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_undo_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_undo_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="undo"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush undo PACKAGE [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_info_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_info_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="info"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush info PACKAGE [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_list_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_list_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="list"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --search | -s )
      if [[ $2 && $2 != -* ]]; then
        args[--search]="$2"
        shift
        shift
      else
        printf "--search requires an argument: --search, -s TEXT\n"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo_or_package]} ]]; then
        args[repo_or_package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_pull_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_pull_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="pull"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_push_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_push_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="push"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --message | -m )
      if [[ $2 && $2 != -* ]]; then
        args[--message]="$2"
        shift
        shift
      else
        printf "--message requires an argument: --message, -m TEXT\n"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_requirements
rush_default_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    rush_default_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="default"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[repo]=$1
    shift
  else
    printf "missing required argument: REPO\nusage: rush default REPO [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.initialize
initialize() {
  version="0.3.4"
  long_usage=''
  set -e  

  # :src/initialize.sh
  CONFIG_FILE=${RUSH_CONFIG:-~/rush.ini}
}

# :command.run
run() {
  declare -A args
  parse_requirements "$@"

  if [[ $action == "add" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_add_usage
    else
      rush_add_command
    fi
  
  elif [[ $action == "clone" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_clone_usage
    else
      rush_clone_command
    fi
  
  elif [[ $action == "remove" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_remove_usage
    else
      rush_remove_command
    fi
  
  elif [[ $action == "config" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_config_usage
    else
      rush_config_command
    fi
  
  elif [[ $action == "get" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_get_usage
    else
      rush_get_command
    fi
  
  elif [[ $action == "undo" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_undo_usage
    else
      rush_undo_command
    fi
  
  elif [[ $action == "info" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_info_usage
    else
      rush_info_command
    fi
  
  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_list_usage
    else
      rush_list_command
    fi
  
  elif [[ $action == "pull" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_pull_usage
    else
      rush_pull_command
    fi
  
  elif [[ $action == "push" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_push_usage
    else
      rush_push_command
    fi
  
  elif [[ $action == "default" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_default_usage
    else
      rush_default_command
    fi
  
  elif [[ ${args[--version]} ]]; then
    version_command
  elif [[ ${args[--help]} ]]; then
    long_usage=yes
    rush_usage
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
