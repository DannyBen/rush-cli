#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
rush_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush - Personal package manager\n"
    echo 
  else
    printf "rush - Personal package manager\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  rush [command]\n"
  printf "  rush [command] --help | -h\n"
  printf "  rush --version | -v\n"
  echo
  # :command.usage_commands
  printf "Repository Commands:\n"
  echo "  add       Register a local repository"
  echo "  remove    Unregister a local repository"
  printf "\nGit Commands:\n"
  echo "  clone     Clone a GitHub package repository"
  echo "  pull      Git pull one or all repositories"
  echo "  push      Git push one or all repositories"
  printf "\nConfig Commands:\n"
  echo "  config    Show or edit the configuration file"
  echo "  default   Set a default repository"
  printf "\nPackage Commands:\n"
  echo "  get       Install a package (default)"
  echo "  undo      Uninstall a package"
  echo "  snatch    Install a package from a remote repo"
  echo "  copy      Copy a package between local repositories"
  echo "  info      Show information about a package"
  echo "  list      Show packages in one or all repositories"
  echo "  search    Search in package names and info files"
  echo "  edit      Edit package files"
  echo "  show      Show package files"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"
    
    # :environment_variable.usage
    echo "  RUSH_CONFIG"
    printf "    Location of the rush config file.\n    Default: ~/rush.ini\n"
    echo

  fi
}

# :command.usage
rush_add_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush add\n"
    echo 
    printf "  Register a local repository\n  This command adds the specified path to the configuration file.\n"
    echo 
  else
    printf "rush add - Register a local repository\n"
    echo 
  fi

  printf "Shortcut: a\n"
  echo

  printf "Usage:\n"
  printf "  rush add REPO PATH\n"
  printf "  rush add --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo
    
    # :argument.usage
    echo "  PATH"
    printf "    Path to the repository.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush add default ~/rush-repos/default\n"
    echo

  fi
}

# :command.usage
rush_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush remove\n"
    echo 
    printf "  Unregister a local repository\n  This command removes the specified path to the configuration file.\n"
    echo 
  else
    printf "rush remove - Unregister a local repository\n"
    echo 
  fi

  printf "Shortcut: r\n"
  echo

  printf "Usage:\n"
  printf "  rush remove REPO [options]\n"
  printf "  rush remove --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --purge, -p"
    printf "    Also remove the local repository's directory.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush remove bobby\n"
    printf "  rush remove bobby --purge\n"
    echo

  fi
}

# :command.usage
rush_clone_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush clone\n"
    echo 
    printf "  Clone a GitHub package repository\n  This command clones the repository and registers it in the\n  configuration file.\n"
    echo 
  else
    printf "rush clone - Clone a GitHub package repository\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  rush clone GITHUB_USER [PATH] [options]\n"
  printf "  rush clone --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --ssh, -s"
    printf "    Clone using SSH instead of HTTPS.\n"
    echo
    
    # :flag.usage
    echo "  --default, -d"
    printf "    Set this as the default repository (same as '--name default').\n"
    echo
    
    # :flag.usage
    echo "  --name, -n NAME"
    printf "    Name to use in the config file.\n    Default: GitHub user\n"
    echo
    
    # :flag.usage
    echo "  --shallow, -w"
    printf "    Perform a shallow clone, instead of the default full clone.\n"
    echo
    
    # :flag.usage
    echo "  --ignore, -i"
    printf "    Ignore (do not clone) if a repository with this name exists.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  GITHUB_USER"
    printf "    Github user.\n    This user is expected to have a repository named 'rush-repo'.\n    If you need to use a different name, use the 'user/repo' syntax.\n"
    echo
    
    # :argument.usage
    echo "  PATH"
    printf "    Local path to clone the repository to.\n    Default: ~/rush-repos/<github_user>/<github_repo>\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush clone bobby\n"
    printf "  rush clone bobby --default\n"
    printf "  rush clone bobby/bobs-repo ./repos/bobby --ssh\n"
    printf "  rush clone bobby --name sample --ignore\n"
    echo

  fi
}

# :command.usage
rush_pull_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush pull - Git pull one or all repositories\n"
    echo 
  else
    printf "rush pull - Git pull one or all repositories\n"
    echo 
  fi

  printf "Shortcut: p\n"
  echo

  printf "Usage:\n"
  printf "  rush pull [REPO]\n"
  printf "  rush pull --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo

  fi
}

# :command.usage
rush_push_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush push - Git push one or all repositories\n"
    echo 
  else
    printf "rush push - Git push one or all repositories\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  rush push [REPO] [options]\n"
  printf "  rush push --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --all, -a"
    printf "    Push all repositories.\n"
    echo
    
    # :flag.usage
    echo "  --message, -m TEXT"
    printf "    Commit message.\n    Default: automatic commit\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n    Default: default\n"
    echo

  fi
}

# :command.usage
rush_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush config - Show or edit the configuration file\n"
    echo 
  else
    printf "rush config - Show or edit the configuration file\n"
    echo 
  fi

  printf "Shortcut: c\n"
  echo

  printf "Usage:\n"
  printf "  rush config [options]\n"
  printf "  rush config --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --edit, -e"
    printf "    Open the configuration file for editing.\n"
    echo

  fi
}

# :command.usage
rush_default_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush default\n"
    echo 
    printf "  Set a default repository\n  This command adds (or updates) a repository named 'default' to the\n  configuration file, and copies the path from the provided repo.\n"
    echo 
  else
    printf "rush default - Set a default repository\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  rush default REPO\n"
  printf "  rush default --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Repository name.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush default sample\n"
    echo

  fi
}

# :command.usage
rush_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush get\n"
    echo 
    printf "  Install a package\n  This command runs the main script in the package directory.\n  \n  This is the default command, which means that running 'rush package' is\n  the same as running 'rush get package'.\n"
    echo 
  else
    printf "rush get - Install a package\n"
    echo 
  fi

  printf "Shortcut: g\n"
  echo

  printf "Usage:\n"
  printf "  rush get PACKAGE [options]\n"
  printf "  rush get --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --clone, -c"
    printf "    Clone the repository if it is not found locally.\n    This flag will look for a GitHub user with the same name as the\n    repository, and attempt to clone their rush-repo repository.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush ruby\n"
    printf "  rush get ruby\n"
    printf "  rush get centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_undo_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush undo\n"
    echo 
    printf "  Uninstall a package\n  This command runs the undo script in the package directory.\n"
    echo 
  else
    printf "rush undo - Uninstall a package\n"
    echo 
  fi

  printf "Shortcut: u\n"
  echo

  printf "Usage:\n"
  printf "  rush undo PACKAGE\n"
  printf "  rush undo --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush undo ruby\n"
    printf "  rush undo centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_snatch_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush snatch\n"
    echo 
    printf "  Install a package from a remote repo\n  This command is a shortcut to running clone followed by get.\n  It will clone the repository to a temporary directory and run the main\n  package script.\n"
    echo 
  else
    printf "rush snatch - Install a package from a remote repo\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  rush snatch GITHUB_USER PACKAGE\n"
  printf "  rush snatch --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  GITHUB_USER"
    printf "    Github user.\n    This user is expected to have a repository named 'rush-repo'.\n    If you need to use a different name, use the 'user/repo' syntax.\n"
    echo
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush snatch james python\n"
    printf "  rush snatch james/other-rush-repo python\n"
    echo

  fi
}

# :command.usage
rush_copy_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush copy - Copy a package between local repositories\n"
    echo 
  else
    printf "rush copy - Copy a package between local repositories\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  rush copy SOURCE_PACKAGE [TARGET_PACKAGE] [options]\n"
  printf "  rush copy --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    Copy the package even if it already exists in the target repository.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  SOURCE_PACKAGE"
    printf "    Source package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo
    
    # :argument.usage
    echo "  TARGET_PACKAGE"
    printf "    Target package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n    If left empty, the package will be copied with the same name to the\n    default repository.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush copy james:python\n"
    printf "  rush copy james:python bobby\n"
    printf "  rush copy james:python bobby:python3 --force\n"
    echo

  fi
}

# :command.usage
rush_info_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush info\n"
    echo 
    printf "  Show information about a package\n  This command shows the info file from the package directory.\n"
    echo 
  else
    printf "rush info - Show information about a package\n"
    echo 
  fi

  printf "Shortcut: i\n"
  echo

  printf "Usage:\n"
  printf "  rush info PACKAGE\n"
  printf "  rush info --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush info ruby\n"
    printf "  rush info centos:ruby\n"
    echo

  fi
}

# :command.usage
rush_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush list - Show packages in one or all repositories\n"
    echo 
  else
    printf "rush list - Show packages in one or all repositories\n"
    echo 
  fi

  printf "Shortcut: l\n"
  echo

  printf "Usage:\n"
  printf "  rush list [REPO_OR_PACKAGE] [options]\n"
  printf "  rush list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --simple, -s"
    printf "    Show only package names.\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO_OR_PACKAGE"
    printf "    Repository name or package name.\n    - Leave blank to show all packages in all repositories.\n    - Provide a repository name to show only packages in this repository.\n    - Provide a package name (may be in the form of 'repo:package') to\n      show nested packages.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  rush list\n"
    printf "  rush list personal:apps\n"
    printf "  rush list personal\n"
    printf "  rush list apps\n"
    printf "  rush list apps --simple\n"
    echo

  fi
}

# :command.usage
rush_search_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush search - Search in package names and info files\n"
    echo 
  else
    printf "rush search - Search in package names and info files\n"
    echo 
  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  rush search TEXT\n"
  printf "  rush search --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  TEXT"
    printf "    Text to search for.\n"
    echo

  fi
}

# :command.usage
rush_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush edit - Edit package files\n"
    echo 
  else
    printf "rush edit - Edit package files\n"
    echo 
  fi

  printf "Shortcut: e\n"
  echo

  printf "Usage:\n"
  printf "  rush edit PACKAGE [FILE]\n"
  printf "  rush edit --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo
    
    # :argument.usage
    echo "  FILE"
    printf "    File to edit.\n    Default: main\n"
    echo

  fi
}

# :command.usage
rush_show_usage() {
  if [[ -n $long_usage ]]; then
    printf "rush show - Show package files\n"
    echo 
  else
    printf "rush show - Show package files\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  rush show PACKAGE [FILE]\n"
  printf "  rush show --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  PACKAGE"
    printf "    Package name.\n    This can either be the package name without the repository name (in\n    this case, the default repository will be used) or in the form of\n    'repo:package'.\n"
    echo
    
    # :argument.usage
    echo "  FILE"
    printf "    File to show (show all if not specified).\n"
    echo

  fi
}

# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/abort.sh
abort() {
  red "$1"
  exit 1
}

# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
# 
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/config.sh
# ---
# Config functions
# This file is a part of Bashly standard library
#
# Usage:
# - In your script, set the CONFIG_FILE variable. For rxample:
#   CONFIG_FILE=settings.ini.
#   If it is unset, it will default to 'config.ini'.
# - Use any of the functions below to access the config file.
# ---

# Create a new config file.
# There is normally no need to use this fucntion, it is used by other
# functions as needed.
config_init() {
  CONFIG_FILE=${CONFIG_FILE:=config.ini}
  [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
}

# Get a value from the config
# Usage: result=$(config_get hello)
config_get() {
  key=$1
  regex="^$key *= *(.+)$"

  config_init
  
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[1]}"
      break
    fi
  done < "$CONFIG_FILE"

  echo "$value"
}

# Add or update a key=value pair in the config.
# Usage: config_set key value
config_set() {
  key=$1
  shift
  value="$*"

  config_init

  regex="^($key) *= *.+$"
  output=""
  found_key=""
  
  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[1]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Delete a key from teh config.
# Usage: config_del key
config_del() {
  key=$1

  regex="^($key) *="
  output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

# Show the config file
config_show() {
  config_init
  cat "$CONFIG_FILE"
}

# Return an array of the keys in the config file
# Usage:
#
#   for k in $(config_keys); do
#     echo "- $k = $(config_get "$k")";
#   done
#
config_keys() {
  regex="^([a-zA-Z0-9_\-]+) *="

  config_init

  keys=()
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      keys+=("$key")
    fi
  done < "$CONFIG_FILE"
  echo "${keys[@]}"
}

# Returns true if the specified key exists in the config file
# Usage:
#
#   if config_has_key "key" ; then
#     echo "key exists"
#   fi
#
config_has_key() {
  [[ $(config_get "$1") ]]
}

# :src/lib/is_busybox_grep.sh
is_busybox_grep() {
  grep --version 2>&1 /dev/null | grep -i busybox > /dev/null 2>&1
}

# :src/lib/say.sh
say() {
  printf "%-20s | %s\n" "$(magenta "$1")" "$(bold "${*:2}")"
}

# :src/lib/warn.sh
warn() {
  printf "%-20s | %s\n" "$(red "$1")" "$(red_bold "${*:2}")"
}

# :command.command_functions
# :command.function
rush_add_command() {
  # :src/add_command.sh
  repo=${args[repo]}
  path=${args[path]}
  
  config_set "$repo" "$path"
  say "add" "$repo = $path"
}

# :command.function
rush_remove_command() {
  # :src/remove_command.sh
  repo=${args[repo]}
  purge=${args[--purge]}
  
  say "remove" "$repo"
  
  if [[ $purge ]] ; then
    repo_path=$(config_get "$repo")
    if [[ -d $repo_path ]] ; then
      rm -rf "$repo_path"
      say "remove" "purged $repo_path"
    fi
  fi
  
  config_del "$repo"
}

# :command.function
rush_clone_command() {
  # :src/clone_command.sh
  # Collect variables
  path=${args[path]}
  repo_id=${args[github_user]}
  use_ssh=${args[--ssh]}
  shallow=${args[--shallow]}
  ignore=${args[--ignore]}
  default_repo_name=${repo_id%%/*}
  default=${args[--default]}
  
  if [[ $default ]] ; then
    repo_name=default
  else
    repo_name=${args[--name]:-$default_repo_name}
  fi
  
  # Adjust repo_id - defaults to $user/rush-repo
  [[ $repo_id = */* ]] || repo_id="$repo_id/rush-repo"
  
  # Set clone URL - ssh or https?
  if [[ $use_ssh ]] ; then
    repo_url=git@github.com:$repo_id.git
  else
    repo_url=https://github.com/$repo_id.git
  fi
  
  # Set default path if not provided
  [[ $path ]] || path="$HOME/rush-repos/$repo_id"
  
  # Abort if target directory exists
  if [[ -d $path ]] ; then
    if [[ $ignore ]] ; then
      skip=1
    else
      abort "directory $path already exists."
    fi
  fi
  
  # Abort if a repository with this name already exists
  if config_has_key "$repo_name" ; then
    if [[ $ignore ]] ; then
      skip=1
    else
      abort "the repository is already registered:\n$repo_name = $(config_get "$repo_name")."
    fi
  fi
  
  if [[ $skip ]] ; then
    say "clone" "skipping $repo_name (exists)"
  
  else
    # Clone
    say "clone" "$repo_url"
  
    if [[ $shallow ]]; then
      git clone --depth 1 "$repo_url" "$path"
    else
      git clone "$repo_url" "$path"
    fi
  
    # Save config
    config_set "$repo_name" "$path"
  
  fi
}

# :command.function
rush_pull_command() {
  # :src/pull_command.sh
  repo=${args[repo]}
  
  pull_repo() {
    local repo_path="$1"
    local repo="$2"
  
    if [[ -d "$repo_path/.git" ]]; then
      say "pull" "$repo"
      ( cd "$repo_path" && git pull )
    else
      say "pull" "skipping $repo (not a git repo)"
    fi
  }
  
  if [[ $repo ]]; then
    repo_path=$(config_get "$repo")
    [[ $repo_path ]] || abort "no such repo: $repo"
    pull_repo "$repo_path" "$repo"
  else
    for k in $(config_keys); do
      pull_repo "$(config_get "$k")" "$k"
    done
  fi
}

# :command.function
rush_push_command() {
  # :src/push_command.sh
  set +e
  all=${args[--all]}
  repo=${args[repo]:-default}
  message=${args[--message]:-"automatic commit"}
  
  push_repo() {
    local repo_path="$1"
    local repo="$2"
  
    if [[ -d "$repo_path/.git" ]]; then
      say "push" "$repo"
      (
        set -e
        cd "$repo_path"
        git add . --all
        find . -type f \( -name main -o -name undo \) -exec git update-index --chmod +x {} \;
        git commit -am "$message"
        git push
      )
    else
      say "push" "skipping $repo (not a git repo)"
    fi
  }
  
  if [[ $all ]]; then
    for k in $(config_keys); do
      push_repo "$(config_get "$k")" "$k"
    done
  else
    repo_path=$(config_get "$repo")
    [[ $repo_path ]] || abort "no such repo: $repo"
    push_repo "$repo_path" "$repo"
  fi
}

# :command.function
rush_config_command() {
  # :src/config_command.sh
  if [[ "${args[--edit]}" ]]; then
    editor="${EDITOR:-vi}"
    "$editor" "$CONFIG_FILE"
  else
    cyan "# $CONFIG_FILE"
    config_show
  fi
}

# :command.function
rush_default_command() {
  # :src/default_command.sh
  # Collect variables
  repo=${args[repo]}
  repo_path=$(config_get "$repo")
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  
  config_set "default" "$repo_path"
  config_del "$repo"
  say "default" "$repo ($repo_path)"
}

# :command.function
rush_get_command() {
  # :src/get_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"
  clone=${args[--clone]}
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  if ! config_has_key "$repo" && [[ $clone ]] && [[ $repo != 'default' ]]; then
    say "get" "repo $repo does not exist, attempting clone"
    rush clone "$repo"
  fi
  
  repo_path=$(config_get "$repo")
  package_path=$repo_path/$package
  script=$package_path/main
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $script ]] || abort "script not found: $script"
  
  # Run the script (make it executable if it isnt first)
  export REPO="$repo"
  export REPO_PATH="$repo_path"
  [[ -z "$USER_CWD" ]] && export USER_CWD="$PWD"
  
  if [[ $repo == "default" ]] ; then
    package_name="$package"
  else
    package_name="$repo:$package"
  fi
  
  say "get" "$package_name"
  [[ -x "$script" ]] || chmod u+x "$script"
  cd "$package_path"
  
  finish() {
    exitcode="$?"
    [[ $exitcode == 0 ]] || warn "get" "$package_name exited with error ($exitcode)"
  }
  
  trap finish EXIT
  
  ./main
}

# :command.function
rush_undo_command() {
  # :src/undo_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  repo_path=$(config_get "$repo")
  package_path=$repo_path/$package
  script=$package_path/undo
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $script ]] || abort "script not found: $script"
  
  # Run the script (make it executable if it isnt first)
  export REPO="$repo"
  export REPO_PATH="$repo_path"
  [[ -z "$USER_CWD" ]] && export USER_CWD="$PWD"
  
  if [[ $repo == "default" ]] ; then
    package_name="$package"
  else
    package_name="$repo:$package"
  fi
  
  say "undo" "$package_name"
  [[ -x "$script" ]] || chmod u+x "$script"
  cd "$package_path"
  
  finish() {
    exitcode="$?"
    [[ $exitcode == 0 ]] || warn "undo" "$package_name exited with error ($exitcode)"
  }
  
  trap finish EXIT
  
  ./undo
}

# :command.function
rush_snatch_command() {
  # :src/snatch_command.sh
  # Collect variables
  repo_id=${args[github_user]}
  package=${args[package]}
  path="$HOME/rush-repos/snatched"
  
  cleanup() {
    rush remove snatched --purge
  }
  
  say "snatch" "$repo_id $package"
  
  trap cleanup EXIT ERR INT TERM
  
  rush clone "$repo_id" "$path" --name snatched
  rush get "snatched:$package"
}

# :command.function
rush_copy_command() {
  # :src/copy_command.sh
  source_package=${args[source_package]}
  target_package=${args[target_package]}
  force=${args[--force]}
  source_repo=default
  target_repo=default
  
  if [[ $source_package =~ (.*):(.*) ]]; then
    source_repo=${BASH_REMATCH[1]}
    source_package=${BASH_REMATCH[2]}
  fi
  
  if [[ -z "$target_package" ]]; then
    target_package="$source_package"
  elif [[ $target_package =~ (.*):(.*) ]]; then
    target_repo=${BASH_REMATCH[1]}
    target_package=${BASH_REMATCH[2]}
  fi
  
  source_repo_path=$(config_get "$source_repo")
  target_repo_path=$(config_get "$target_repo")
  source_package_path="$source_repo_path/$source_package"
  target_package_path="$target_repo_path/$target_package"
  
  if [[ $source_repo == "default" ]]; then
    source_display_name="$source_package"
  else
    source_display_name="$source_repo:$source_package"
  fi
  
  if [[ $target_repo == "default" ]]; then
    target_display_name="$target_package"
  else
    target_display_name="$target_repo:$target_package"
  fi
  
  [[ $source_repo_path ]] || abort "source repo not found: $source_repo"
  [[ $target_repo_path ]] || abort "target repo not found: $target_repo"
  [[ -d $source_package_path ]] || abort "source package not found: $source_repo:$source_package"
  if [[ -d $target_package_path ]]; then
    if [[ $force ]]; then
      rm -rf "$target_package_path"
    else
      abort "target package already exists: $target_repo:$target_package\nrun again with --force to copy anyway"
    fi
  fi
  
  say "copy" "$source_display_name to $target_display_name"
  mkdir -p "$(dirname "$target_package_path")"
  cp -R "$source_package_path" "$target_package_path"
}

# :command.function
rush_info_command() {
  # :src/info_command.sh
  # Collect variables
  package=${args[package]}
  repo="default"
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  repo_path=$(config_get "$repo")
  package_path="$repo_path/$package"
  infofile="$package_path/info"
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $infofile ]] || abort "infofile not found: $infofile"
  
  cat "$infofile"
}

# :command.function
rush_list_command() {
  # :src/list_command.sh
  list_display_item() {
    package="$1"
    infofile="$2"
    repo="$3"
    simple=${args[--simple]}
    width=$(( ${COLUMNS:-80} + 9))
  
    [[ "$repo" != "default" ]] && package="$repo:$package"
    if [[ $simple ]]; then
      printf "%s\n" "$package"
    else
      info=$(head -1 "$infofile" 2> /dev/null)
      padded_package=$(printf "%-20s" "$package")
      message="$(green "$padded_package")  $info"
      printf "%.${width}s\n" "$message"
    fi
  }
  
  list_show_repo() {
    local repo_or_package="$1"
    local search="${args[--search]}"
    local simple=${args[--simple]}
    local repo="$repo_or_package"
    local package glob repo_path infofile regex package_name
  
    if [[ $repo_or_package =~ (.*):(.*) ]]; then
      repo=${BASH_REMATCH[1]}
      package=${BASH_REMATCH[2]}
    fi
  
    repo_path=$(config_get "$repo")
  
    if [[ ! $repo_path ]]; then
      package="$repo"
      repo="default"
      repo_path=$(config_get "$repo")
    fi
  
    if [[ $package ]]; then
      glob=( "$repo_path"/"$package"/*/info )
    else
      glob=( "$repo_path"/*/info )
    fi
  
    if [[ ${glob[0]} =~ .*\*.* ]]; then
      infofile="$repo_path/$package/info"
      if [[ -f "$infofile" ]]; then
        list_display_item "$package" "$infofile" "$repo"
      elif [[ ! $simple ]]; then
        red "nothing in $repo trpo"
      fi
    
    else
      for infofile in "${glob[@]}"; do
        if [[ $search ]]; then
          regex="$repo_path/(.*${search}.*)/info"
        else
          regex="$repo_path/(.*)/info"
        fi
  
        if [[ $infofile =~ $regex ]]; then
          package_name="${BASH_REMATCH[1]}"
          list_display_item "$package_name" "$infofile" "$repo"
        fi
      done
    fi
  }
  
  repo_or_package=${args[repo_or_package]}
  
  if [[ $repo_or_package ]]; then
    list_show_repo "$repo_or_package"
  else
    for k in $(config_keys); do
      list_show_repo "$k"
    done
  fi
}

# :command.function
rush_search_command() {
  # :src/search_command.sh
  search_repo() {
    repo="$1"
    text="$2"
    set +e
  
    repo_path=$(config_get "$repo")
  
    # Add "repo:" to the result unless it is the default
    prefix=''
    [[ "$repo" != "default" ]] && prefix="$repo:"
  
    # Search directories matching search text
    blue "Matching packages:\n"
    find "$repo_path" -type d -not -path '*/\.*' | grep --color=always "$text" | \
      sed "s#${repo_path}/#${prefix}#g" | sed 's#/info##'
  
    # Search info files matching search text
    blue "\nMatching info files:\n"
    grep --color=always --initial-tab --recursive --ignore-case --include "info" \
      "$text" "$repo_path" | \
      sort | \
      sed "s#${repo_path}/#${prefix}#g" | sed 's#/info##'
  
    echo
  }
  
  if is_busybox_grep; then
    abort "cannot run with BusyBox grep.\nplease install GNU grep:\napk add --no-cache grep"
  fi
  
  text=${args[text]}
  
  for k in $(config_keys); do
    search_repo "$k" "$text"
  done
}

# :command.function
rush_edit_command() {
  # :src/edit_command.sh
  # Collect variables
  package=${args[package]}
  file=${args[file]:-main}
  repo="default"
  edit=${EDITOR:-vi}
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  repo_path=$(config_get "$repo")
  package_path="$repo_path/$package"
  file_path="$package_path/$file"
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  [[ -f $file_path ]] || abort "file not found: $file_path"
  
  # Edit the file
  "$edit" "$file_path"
}

# :command.function
rush_show_command() {
  # :src/show_command.sh
  # Collect variables
  package=${args[package]}
  file=${args[file]}
  repo="default"
  
  if [[ $package =~ (.*):(.*) ]]; then
    repo=${BASH_REMATCH[1]}
    package=${BASH_REMATCH[2]}
  fi
  
  repo_path=$(config_get "$repo")
  package_path="$repo_path/$package"
  file_path="$package_path/$file"
  
  # Verify we have everything we need
  [[ $repo_path ]] || abort "repo not found: $repo"
  [[ -d $package_path ]] || abort "package not found: $repo:$package"
  
  # Show the package data
  if [[ $file ]]; then
    [[ -f $file_path ]] || abort "file not found: $file_path"
    cat "$file_path"
  else
    shopt -s dotglob
    for f in "$package_path"/*; do
      green "$(basename "$f")"
      cat "$f"
      echo
      echo
    done
    shopt -u dotglob
  fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  add | a )
    action="add"
    shift
    rush_add_parse_requirements "$@"
    shift $#
    ;;    
  
  remove | r )
    action="remove"
    shift
    rush_remove_parse_requirements "$@"
    shift $#
    ;;    
  
  clone )
    action="clone"
    shift
    rush_clone_parse_requirements "$@"
    shift $#
    ;;    
  
  pull | p )
    action="pull"
    shift
    rush_pull_parse_requirements "$@"
    shift $#
    ;;    
  
  push )
    action="push"
    shift
    rush_push_parse_requirements "$@"
    shift $#
    ;;    
  
  config | c )
    action="config"
    shift
    rush_config_parse_requirements "$@"
    shift $#
    ;;    
  
  default )
    action="default"
    shift
    rush_default_parse_requirements "$@"
    shift $#
    ;;    
  
  get | g )
    action="get"
    shift
    rush_get_parse_requirements "$@"
    shift $#
    ;;    
  
  undo | u )
    action="undo"
    shift
    rush_undo_parse_requirements "$@"
    shift $#
    ;;    
  
  snatch )
    action="snatch"
    shift
    rush_snatch_parse_requirements "$@"
    shift $#
    ;;    
  
  copy )
    action="copy"
    shift
    rush_copy_parse_requirements "$@"
    shift $#
    ;;    
  
  info | i )
    action="info"
    shift
    rush_info_parse_requirements "$@"
    shift $#
    ;;    
  
  list | l )
    action="list"
    shift
    rush_list_parse_requirements "$@"
    shift $#
    ;;    
  
  search | s )
    action="search"
    shift
    rush_search_parse_requirements "$@"
    shift $#
    ;;    
  
  edit | e )
    action="edit"
    shift
    rush_edit_parse_requirements "$@"
    shift $#
    ;;    
  
  show )
    action="show"
    shift
    rush_show_parse_requirements "$@"
    shift $#
    ;;    
  
  # :command.command_fallback
  "" )
    rush_usage
    exit 1
    ;;
  
  * )
    action="get"
    rush_get_parse_requirements "$@"
    shift $#
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_add_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_add_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="add"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[repo]=$1
    shift
  else
    printf "missing required argument: REPO\nusage: rush add REPO PATH\n"
    exit 1
  fi
  
  if [[ $1 && $1 != -* ]]; then
    args[path]=$1
    shift
  else
    printf "missing required argument: PATH\nusage: rush add REPO PATH\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      elif [[ ! ${args[path]} ]]; then
        args[path]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_remove_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_remove_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="remove"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[repo]=$1
    shift
  else
    printf "missing required argument: REPO\nusage: rush remove REPO [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --purge | -p )
      args[--purge]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_clone_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_clone_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="clone"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[github_user]=$1
    shift
  else
    printf "missing required argument: GITHUB_USER\nusage: rush clone GITHUB_USER [PATH] [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --ssh | -s )
      args[--ssh]=1
      shift
      ;;
  
    # :flag.case
    --default | -d )
      args[--default]=1
      shift
      ;;
  
    # :flag.case
    --name | -n )
      if [[ $2 ]]; then
        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name, -n NAME"
        exit 1
      fi
      ;;
  
    # :flag.case
    --shallow | -w )
      args[--shallow]=1
      shift
      ;;
  
    # :flag.case
    --ignore | -i )
      args[--ignore]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[github_user]} ]]; then
        args[github_user]=$1
        shift
      elif [[ ! ${args[path]} ]]; then
        args[path]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_pull_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_pull_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="pull"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_push_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_push_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="push"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --all | -a )
      args[--all]=1
      shift
      ;;
  
    # :flag.case
    --message | -m )
      if [[ $2 ]]; then
        args[--message]="$2"
        shift
        shift
      else
        printf "%s\n" "--message requires an argument: --message, -m TEXT"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_config_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_config_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="config"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --edit | -e )
      args[--edit]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_default_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_default_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="default"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[repo]=$1
    shift
  else
    printf "missing required argument: REPO\nusage: rush default REPO\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_get_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_get_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="get"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush get PACKAGE [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --clone | -c )
      args[--clone]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_undo_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_undo_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="undo"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush undo PACKAGE\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_snatch_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_snatch_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="snatch"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[github_user]=$1
    shift
  else
    printf "missing required argument: GITHUB_USER\nusage: rush snatch GITHUB_USER PACKAGE\n"
    exit 1
  fi
  
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush snatch GITHUB_USER PACKAGE\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[github_user]} ]]; then
        args[github_user]=$1
        shift
      elif [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_copy_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_copy_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="copy"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[source_package]=$1
    shift
  else
    printf "missing required argument: SOURCE_PACKAGE\nusage: rush copy SOURCE_PACKAGE [TARGET_PACKAGE] [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --force | -f )
      args[--force]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[source_package]} ]]; then
        args[source_package]=$1
        shift
      elif [[ ! ${args[target_package]} ]]; then
        args[target_package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_info_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_info_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="info"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush info PACKAGE\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_list_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_list_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="list"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --simple | -s )
      args[--simple]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo_or_package]} ]]; then
        args[repo_or_package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_search_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_search_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="search"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[text]=$1
    shift
  else
    printf "missing required argument: TEXT\nusage: rush search TEXT\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[text]} ]]; then
        args[text]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_edit_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_edit_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="edit"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush edit PACKAGE [FILE]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      elif [[ ! ${args[file]} ]]; then
        args[file]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
rush_show_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    rush_show_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="show"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[package]=$1
    shift
  else
    printf "missing required argument: PACKAGE\nusage: rush show PACKAGE [FILE]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[package]} ]]; then
        args[package]=$1
        shift
      elif [[ ! ${args[file]} ]]; then
        args[file]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.initialize
initialize() {
  version="0.6.3"
  long_usage=''
  set -e  

  # :src/initialize.sh
  CONFIG_FILE=${RUSH_CONFIG:-~/rush.ini}
}

# :command.run
run() {
  declare -A args
  declare -a other_args
  parse_requirements "$@"

  if [[ $action == "add" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_add_usage
    else
      rush_add_command
    fi
  
  elif [[ $action == "remove" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_remove_usage
    else
      rush_remove_command
    fi
  
  elif [[ $action == "clone" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_clone_usage
    else
      rush_clone_command
    fi
  
  elif [[ $action == "pull" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_pull_usage
    else
      rush_pull_command
    fi
  
  elif [[ $action == "push" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_push_usage
    else
      rush_push_command
    fi
  
  elif [[ $action == "config" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_config_usage
    else
      rush_config_command
    fi
  
  elif [[ $action == "default" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_default_usage
    else
      rush_default_command
    fi
  
  elif [[ $action == "get" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_get_usage
    else
      rush_get_command
    fi
  
  elif [[ $action == "undo" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_undo_usage
    else
      rush_undo_command
    fi
  
  elif [[ $action == "snatch" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_snatch_usage
    else
      rush_snatch_command
    fi
  
  elif [[ $action == "copy" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_copy_usage
    else
      rush_copy_command
    fi
  
  elif [[ $action == "info" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_info_usage
    else
      rush_info_command
    fi
  
  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_list_usage
    else
      rush_list_command
    fi
  
  elif [[ $action == "search" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_search_usage
    else
      rush_search_command
    fi
  
  elif [[ $action == "edit" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_edit_usage
    else
      rush_edit_command
    fi
  
  elif [[ $action == "show" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      rush_show_usage
    else
      rush_show_command
    fi
  
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
